******************************** Defining a Thread by implementing Runnable(I) **********************************
We can define a thread by implementing Runnable Interface.
1st approach => myThread -> Thread -> Runnable(I)
2nd approach => myRunnable -> Runnable(I)

Runnable Interface present in java.lang package and it contains only one method which is run() method. public void run();
Example:

class myRunnable implements Runnable{
  public void run(){  
    for(int i = 0; i<=10; i++){  //executed my child thread
      System.out.println("Child thread");
    }
  }
}

class ThreadDemo{
  public static void main(String[] args){
    myRunnable r = new myRunnable();
    Thread t = new Thread(r);
    t.start();
    for(int i = 0; i<=10; i++){  // executed by main thread
    System.out.println("Main thread");
    }
  }
}

We will get mixed output and we can't tell exact output.

CASE STUDY:
myRunnable r = new myRunnable();
Thread t1 = new Thread();
Thread t2 = new Thread(r);

case i  : t1.start();
-> A new thread will be created which is responsible for execution of Thread class run method, which has empty implementation.

case ii : t1.run();
-> No new thread will be created and Thread class run method will be executed just like a normal method call.

case iii: t2.start();
-> A new thread will be created which is responsible for the execution of myRunnable class run() method.

case iv : t2.run();
-> A new thread won't be created and myRunnable run() method will be executed just like a normal method call.

case v  : r.start();  
We will get compile-time error saying:myRunnable class doesn't have start() capability.
//CE: cannot find symbol: symbol method start() location class myRunnable

case vi : r.run();
-> No new thread will be created and myRunnable run() method will be executed like normal method call.


******************************   **************************************
Which approach is best to define a thread ?
-> Among two ways of defining a thread, implements Runnable approach is recommended.
In the first approach, our class always extends Thread class , there is no chance of extending any other class. Hence, we are missing inheritance benefit.
But in the second approach, while implementing Runnable Interface, we can extend any other class . Hence, we won't miss any inheritance benefit.
Because of above reason, implementing Runnable Interface approach is recommended than extending Thread class.


************************** Getting and Setting name of a Thread ********************************************************
Every thread in java has some name.
It may be default name generated by JVM or customized name provided by programmer.
We can get and set Name of a thread by using the following two method of Thread class.
i. public final String getName()
ii. public final void setName(String name)

Example:
class Program {
  public static void main(String[] args){
    System.out.println(Thread.currentThread().getName()); //main
    myThread t1 = new myThread();
    System.out.println(t1.getName());  //Thread-0
    Thread.currentThread().setName("aashish");
    System.out.println(Thread.currentThread().getName()); //aashish
   }
  }

  class myThread extends Thread{
  
  }

=> We can get current executing Thread object by using Thread.currentThread() method.
class Program {
  public static void main(String[] args){
    myThread t1 = new myThread();
    t1.start();
          System.out.println("main method executed by Main Thread:"+Thread.currentThread().getName());
   }
  }

  class myThread extends Thread{
    public void run(){
      System.out.println("run method executed by Thread:"+Thread.currentThread().getName());
    }
  }


 
